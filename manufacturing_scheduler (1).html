<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manufacturing Production Scheduler</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            margin-bottom: 10px;
        }

        .controls {
            background: white;
            padding: 20px;
            margin: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .control-group {
            display: inline-block;
            margin-right: 20px;
            margin-bottom: 10px;
        }

        .control-group label {
            display: inline-block;
            width: 180px;
            font-weight: 600;
            color: #333;
        }

        .control-group input, .control-group select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 120px;
            font-size: 14px;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background: #667eea;
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        button:hover {
            background: #5a67d8;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .gantt-container {
            margin: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            overflow: auto;
            max-height: 70vh;
            position: relative;
        }

        .gantt-header {
            display: flex;
            position: sticky;
            top: 0;
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            z-index: 100;
            min-height: 60px;
        }

        .gantt-header-product {
            width: 150px;
            padding: 10px;
            font-weight: bold;
            background: #e9ecef;
            border-right: 1px solid #dee2e6;
            position: sticky;
            left: 0;
            z-index: 101;
        }

        .gantt-header-timeline {
            display: flex;
            overflow: visible;
            position: relative;
        }

        .gantt-day-header {
            min-width: 30px;
            padding: 5px 2px;
            text-align: center;
            border-right: 1px solid #e0e0e0;
            cursor: pointer;
            font-size: 11px;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            user-select: none;
        }

        .gantt-day-header:hover {
            background: #e3f2fd;
        }

        .gantt-day-header.weekend {
            background: #f5f5f5;
        }

        .gantt-day-header.holiday {
            background: #ffebee;
        }

        .gantt-day-header.vertical-day {
            background: #fff3e0;
            text-decoration: line-through;
        }

        .gantt-body {
            position: relative;
        }

        .gantt-row {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            min-height: 40px;
            position: relative;
        }

        .gantt-row:hover {
            background: #fafafa;
        }

        .gantt-product-label {
            width: 150px;
            padding: 10px;
            font-weight: 500;
            background: white;
            border-right: 1px solid #dee2e6;
            position: sticky;
            left: 0;
            z-index: 10;
            display: flex;
            align-items: center;
            font-size: 12px;
        }

        .gantt-timeline {
            display: flex;
            position: relative;
            flex: 1;
        }

        .gantt-day-cell {
            min-width: 30px;
            height: 40px;
            border-right: 1px solid #f0f0f0;
            position: relative;
        }

        .gantt-day-cell.weekend {
            background: #fafafa;
        }

        .gantt-day-cell.holiday {
            background: #fff5f5;
        }

        .gantt-day-cell.vertical-day {
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 5px,
                rgba(255,193,7,0.1) 5px,
                rgba(255,193,7,0.1) 10px
            );
        }

        .gantt-bar {
            position: absolute;
            height: 30px;
            top: 5px;
            border-radius: 4px;
            color: white;
            font-size: 11px;
            display: flex;
            align-items: center;
            padding: 0 5px;
            cursor: move;
            transition: transform 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            z-index: 5;
        }

        .gantt-bar:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 20;
        }

        .gantt-bar.dragging {
            opacity: 0.8;
            z-index: 1000;
        }

        /* Position colors for Assembly Line A (darkest) */
        .gantt-bar.line-A.pos-0 { background: #b71c1c; }
        .gantt-bar.line-A.pos-1 { background: #d84315; }
        .gantt-bar.line-A.pos-2 { background: #ef6c00; }
        .gantt-bar.line-A.pos-3 { background: #f57c00; }
        .gantt-bar.line-A.pos-4 { background: #ff9800; }
        .gantt-bar.line-A.pos-5 { background: #ffa726; }
        .gantt-bar.line-A.pos-6 { background: #ffb300; }
        .gantt-bar.line-A.pos-7 { background: #ffc107; }
        .gantt-bar.line-A.pos-8 { background: #ffd54f; }
        .gantt-bar.line-A.pos-9 { background: #ffee58; color: #333; }
        .gantt-bar.line-A.pos-FGI { background: #1976d2; }
        .gantt-bar.line-A.pos-Delivery { background: #7b1fa2; }

        /* Position colors for Assembly Line B (lighter) */
        .gantt-bar.line-B.pos-0 { background: #e53935; }
        .gantt-bar.line-B.pos-1 { background: #ff5722; }
        .gantt-bar.line-B.pos-2 { background: #ff7043; }
        .gantt-bar.line-B.pos-3 { background: #ff8a65; }
        .gantt-bar.line-B.pos-4 { background: #ffab91; }
        .gantt-bar.line-B.pos-5 { background: #ffb74d; }
        .gantt-bar.line-B.pos-6 { background: #ffcc80; }
        .gantt-bar.line-B.pos-7 { background: #ffd180; }
        .gantt-bar.line-B.pos-8 { background: #ffe082; }
        .gantt-bar.line-B.pos-9 { background: #fff176; color: #333; }
        .gantt-bar.line-B.pos-FGI { background: #42a5f5; }
        .gantt-bar.line-B.pos-Delivery { background: #ab47bc; }

        /* Position colors for Assembly Line C (even lighter) */
        .gantt-bar.line-C.pos-0 { background: #ef5350; }
        .gantt-bar.line-C.pos-1 { background: #ff8a65; }
        .gantt-bar.line-C.pos-2 { background: #ffab91; }
        .gantt-bar.line-C.pos-3 { background: #ffb74d; }
        .gantt-bar.line-C.pos-4 { background: #ffcc80; }
        .gantt-bar.line-C.pos-5 { background: #ffd54f; }
        .gantt-bar.line-C.pos-6 { background: #ffdf80; }
        .gantt-bar.line-C.pos-7 { background: #ffe57f; }
        .gantt-bar.line-C.pos-8 { background: #ffeb3b; color: #333; }
        .gantt-bar.line-C.pos-9 { background: #fff59d; color: #333; }
        .gantt-bar.line-C.pos-FGI { background: #90caf9; }
        .gantt-bar.line-C.pos-Delivery { background: #ce93d8; }

        /* Position colors for Assembly Line D (lightest) */
        .gantt-bar.line-D.pos-0 { background: #ffcdd2; }
        .gantt-bar.line-D.pos-1 { background: #ffccbc; }
        .gantt-bar.line-D.pos-2 { background: #ffccbc; }
        .gantt-bar.line-D.pos-3 { background: #ffe0b2; }
        .gantt-bar.line-D.pos-4 { background: #ffecb3; }
        .gantt-bar.line-D.pos-5 { background: #fff3e0; }
        .gantt-bar.line-D.pos-6 { background: #fff8e1; }
        .gantt-bar.line-D.pos-7 { background: #fffde7; color: #333; }
        .gantt-bar.line-D.pos-8 { background: #ffffe0; color: #333; }
        .gantt-bar.line-D.pos-9 { background: #fffff8; color: #333; }
        .gantt-bar.line-D.pos-FGI { background: #bbdefb; }
        .gantt-bar.line-D.pos-Delivery { background: #e1bee7; }

        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
            min-width: 200px;
        }

        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
        }

        .context-menu-item:hover {
            background: #f0f0f0;
        }

        .legend {
            background: white;
            padding: 15px;
            margin: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .legend-item {
            display: inline-block;
            margin: 5px 15px 5px 0;
            font-size: 12px;
        }

        .legend-color {
            display: inline-block;
            width: 20px;
            height: 15px;
            margin-right: 5px;
            border-radius: 3px;
            vertical-align: middle;
        }

        .stats {
            background: white;
            padding: 15px;
            margin: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .stat-item {
            display: inline-block;
            margin-right: 30px;
            font-size: 14px;
        }

        .stat-label {
            font-weight: 600;
            color: #666;
        }

        .stat-value {
            color: #333;
            font-weight: 500;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .modal h3 {
            margin-bottom: 15px;
        }

        .modal input {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 15px 20px;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: none;
            z-index: 3000;
        }

        .toast.show {
            display: block;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
            }
            to {
                transform: translateX(0);
            }
        }

        .tooltip {
            position: fixed;
            background: linear-gradient(135deg, rgba(0,0,0,0.95) 0%, rgba(30,30,30,0.95) 100%);
            color: white;
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 2000;
            white-space: nowrap;
            visibility: hidden;
            opacity: 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
            transition: opacity 0.2s ease-in-out, visibility 0.2s;
        }

        .tooltip.show {
            visibility: visible;
            opacity: 1;
        }

        .tooltip-row {
            margin: 3px 0;
            display: flex;
            align-items: center;
        }

        .tooltip-label {
            font-weight: 600;
            color: #9ca3af;
            display: inline-block;
            margin-right: 10px;
            min-width: 60px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tooltip-value {
            color: white;
            font-weight: 400;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Manufacturing Production Scheduler</h1>
        <p>Interactive Gantt Chart with Drag-and-Drop Scheduling</p>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Days per Position:</label>
            <input type="number" id="daysPerPosition" value="5" min="1">
        </div>
        <div class="control-group">
            <label>Days FGI to Delivery:</label>
            <input type="number" id="daysFGItoDelivery" value="3" min="1">
        </div>
        <div class="control-group">
            <label>Number of Lines:</label>
            <select id="numLines">
                <option value="2" selected>2 (A, B)</option>
                <option value="3">3 (A, B, C)</option>
                <option value="4">4 (A, B, C, D)</option>
            </select>
        </div>
        <div class="control-group">
            <label>Number of Positions:</label>
            <input type="number" id="numPositions" value="4" min="1" max="10">
        </div>
        <div class="control-group">
            <label>Number of Products to Display:</label>
            <input type="number" id="productsPerLine" value="10" min="1">
        </div>
        <div class="control-group">
            <label>Start Date:</label>
            <input type="date" id="startDate" value="2025-09-17">
        </div>
        <button onclick="generateSchedule()">Generate Schedule</button>
        <button onclick="saveSchedule()">Save Schedule</button>
        <button onclick="loadSchedule()">Load Schedule</button>
        <button onclick="exportToExcel()">Export to Excel</button>
    </div>

    <div class="stats" id="stats">
        <div class="stat-item">
            <span class="stat-label">Total Products:</span>
            <span class="stat-value" id="totalProducts">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Schedule Duration:</span>
            <span class="stat-value" id="scheduleDuration">0 days</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Non-Working Days:</span>
            <span class="stat-value" id="nonWorkingDays">0</span>
        </div>
    </div>

    <div class="legend">
        <div class="legend-title">Position Colors (Line A shown):</div>
        <div id="legendContent"></div>
    </div>

    <div class="gantt-container" id="ganttContainer">
        <div class="gantt-header">
            <div class="gantt-header-product">Product / Line</div>
            <div class="gantt-header-timeline" id="ganttHeaderTimeline"></div>
        </div>
        <div class="gantt-body" id="ganttBody"></div>
    </div>

    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="addVerticalDay()">Add Vertical Day (All Lines)</div>
        <div class="context-menu-item" id="lineSpecificMenuItem">Add Non-Working Day (Line X)</div>
        <div class="context-menu-item" onclick="removeNonWorkingDay()">Remove Non-Working Day</div>
        <div class="context-menu-item" onclick="closeContextMenu()">Cancel</div>
    </div>

    <div id="saveModal" class="modal">
        <div class="modal-content">
            <h3>Save Schedule</h3>
            <input type="text" id="saveName" placeholder="Enter schedule name">
            <button onclick="confirmSave()">Save</button>
            <button onclick="closeSaveModal()">Cancel</button>
        </div>
    </div>

    <div id="loadModal" class="modal">
        <div class="modal-content">
            <h3>Load Schedule</h3>
            <select id="loadSelect" style="width: 100%; padding: 8px; margin-bottom: 10px;"></select>
            <button onclick="confirmLoad()">Load</button>
            <button onclick="closeLoadModal()">Cancel</button>
        </div>
    </div>

    <div class="toast" id="toast"></div>
    
    <div class="tooltip" id="tooltip"></div>

    <script>
        // Global variables
        let schedule = [];
        let holidays = [
            '2025-01-01', '2025-01-20', '2025-02-17', '2025-05-26',
            '2025-07-04', '2025-09-01', '2025-11-27', '2025-11-28',
            '2025-12-25', '2025-12-26'
        ];
        let verticalDays = [];
        let lineSpecificNonWorkingDays = {};
        let horizontalDays = {}; // Product-specific delays
        let startDate;
        let endDate;
        let currentContextDate = null;
        let draggedElement = null;
        let draggedProduct = null;
        let draggedPosition = null;

        // Initialize on load
        window.onload = function() {
            generateSchedule();
        };

        // Check if a date is a weekend
        function isWeekend(date) {
            const day = date.getDay();
            return day === 0 || day === 6;
        }

        // Check if a date is a holiday
        function isHoliday(date) {
            const dateStr = formatDate(date);
            return holidays.includes(dateStr);
        }

        // Check if a date is a vertical non-working day
        function isVerticalDay(date) {
            const dateStr = formatDate(date);
            return verticalDays.includes(dateStr);
        }

        // Check if a date is a non-working day for a specific line
        function isLineNonWorkingDay(date, line) {
            const dateStr = formatDate(date);
            return lineSpecificNonWorkingDays[line] && lineSpecificNonWorkingDays[line].includes(dateStr);
        }

        // Check if a date is a horizontal day for a specific product
        function isHorizontalDay(date, productId) {
            const dateStr = formatDate(date);
            return horizontalDays[productId] && horizontalDays[productId].includes(dateStr);
        }

        // Format date to YYYY-MM-DD
        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }

        // Add working days to a date
        function addWorkingDays(startDate, days, line, productId) {
            let date = new Date(startDate);
            let workingDaysAdded = 0;
            
            while (workingDaysAdded < days) {
                date.setDate(date.getDate() + 1);
                if (!isWeekend(date) && !isHoliday(date) && !isVerticalDay(date) && 
                    !isLineNonWorkingDay(date, line) && !isHorizontalDay(date, productId)) {
                    workingDaysAdded++;
                }
            }
            
            return date;
        }

        // Calculate actual calendar days including non-working days
        function calculateCalendarDays(startDate, endDate, line, productId) {
            let days = 0;
            let date = new Date(startDate);
            
            while (date <= endDate) {
                days++;
                date.setDate(date.getDate() + 1);
            }
            
            return days;
        }

        // Generate the production schedule
        function generateSchedule() {
            const daysPerPosition = parseInt(document.getElementById('daysPerPosition').value);
            const daysFGItoDelivery = parseInt(document.getElementById('daysFGItoDelivery').value);
            const numLines = parseInt(document.getElementById('numLines').value);
            const numPositions = parseInt(document.getElementById('numPositions').value);
            const productsPerLine = parseInt(document.getElementById('productsPerLine').value);
            startDate = new Date(document.getElementById('startDate').value);
            
            schedule = [];
            const lines = ['A', 'B', 'C', 'D'].slice(0, numLines);
            
            // Generate position names: 0, 1, 2, ..., numPositions-1, FGI, Delivery
            const positions = [];
            for (let i = 0; i < numPositions; i++) {
                positions.push(i.toString());
            }
            positions.push('FGI', 'Delivery');
            
            // Update legend
            updateLegend(positions);
            
            // Calculate offset between lines (staggered start)
            const lineOffset = Math.floor(daysPerPosition / numLines);
            
            lines.forEach((line, lineIndex) => {
                let currentDate = new Date(startDate);
                
                // Apply line offset for staggered starts
                if (lineIndex > 0) {
                    currentDate = addWorkingDays(currentDate, lineOffset * lineIndex, line, null);
                }
                
                for (let i = 0; i < productsPerLine; i++) {
                    const productId = 1000 + (lineIndex * productsPerLine) + i;
                    const product = {
                        id: productId,
                        line: line,
                        positions: {}
                    };
                    
                    let positionStart = new Date(currentDate);
                    
                    positions.forEach((pos, posIndex) => {
                        const daysInPosition = (pos === 'Delivery') ? daysFGItoDelivery : daysPerPosition;
                        const positionEnd = addWorkingDays(positionStart, daysInPosition - 1, line, productId);
                        
                        product.positions[pos] = {
                            start: new Date(positionStart),
                            end: positionEnd,
                            days: daysInPosition
                        };
                        
                        positionStart = addWorkingDays(positionEnd, 1, line, productId);
                    });
                    
                    schedule.push(product);
                    
                    // Next product starts when current leaves position 0
                    currentDate = addWorkingDays(product.positions['0'].end, 1, line, productId);
                }
            });
            
            // Sort schedule by start date and line
            schedule.sort((a, b) => {
                const dateCompare = a.positions['0'].start - b.positions['0'].start;
                if (dateCompare !== 0) return dateCompare;
                return a.line.localeCompare(b.line);
            });
            
            renderGantt();
            updateStats();
        }

        // Update legend based on number of positions
        function updateLegend(positions) {
            const legendContent = document.getElementById('legendContent');
            legendContent.innerHTML = '';
            
            const positionColors = {
                '0': '#b71c1c',
                '1': '#d84315',
                '2': '#ef6c00',
                '3': '#f57c00',
                '4': '#ff9800',
                '5': '#ffa726',
                '6': '#ffb300',
                '7': '#ffc107',
                '8': '#ffd54f',
                '9': '#ffee58',
                'FGI': '#1976d2',
                'Delivery': '#7b1fa2'
            };
            
            positions.forEach(pos => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                const color = positionColors[pos] || '#999';
                item.innerHTML = `<span class="legend-color" style="background: ${color};"></span>Position ${pos}`;
                legendContent.appendChild(item);
            });
        }

        // Render the Gantt chart
        function renderGantt() {
            if (schedule.length === 0) return;
            
            // Find the overall date range
            startDate = schedule[0].positions['0'].start;
            endDate = new Date(startDate);
            
            schedule.forEach(product => {
                const deliveryEnd = product.positions['Delivery'].end;
                if (deliveryEnd > endDate) {
                    endDate = deliveryEnd;
                }
            });
            
            // Add some buffer days
            endDate.setDate(endDate.getDate() + 30);
            
            // Generate timeline header
            const headerTimeline = document.getElementById('ganttHeaderTimeline');
            headerTimeline.innerHTML = '';
            
            let currentDate = new Date(startDate);
            let dayIndex = 0;
            
            while (currentDate <= endDate) {
                const dayHeader = document.createElement('div');
                dayHeader.className = 'gantt-day-header';
                dayHeader.dataset.date = formatDate(currentDate);
                dayHeader.dataset.index = dayIndex;
                
                // Format display
                const month = currentDate.getMonth() + 1;
                const day = currentDate.getDate();
                dayHeader.innerHTML = `${month}/${day}<br>${currentDate.toLocaleDateString('en-US', {weekday: 'short'}).substring(0,2)}`;
                
                // Apply styling for non-working days
                if (isWeekend(currentDate)) {
                    dayHeader.classList.add('weekend');
                }
                if (isHoliday(currentDate)) {
                    dayHeader.classList.add('holiday');
                }
                if (isVerticalDay(currentDate)) {
                    dayHeader.classList.add('vertical-day');
                }
                
                // Add context menu on right-click
                dayHeader.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    showContextMenu(e, this.dataset.date);
                });
                
                headerTimeline.appendChild(dayHeader);
                
                currentDate.setDate(currentDate.getDate() + 1);
                dayIndex++;
            }
            
            // Generate body rows
            const ganttBody = document.getElementById('ganttBody');
            ganttBody.innerHTML = '';
            
            schedule.forEach((product, productIndex) => {
                const row = document.createElement('div');
                row.className = 'gantt-row';
                row.dataset.productId = product.id;
                
                // Product label
                const label = document.createElement('div');
                label.className = 'gantt-product-label';
                label.textContent = `Product ${product.id} - Line ${product.line}`;
                row.appendChild(label);
                
                // Timeline
                const timeline = document.createElement('div');
                timeline.className = 'gantt-timeline';
                
                // Add day cells
                currentDate = new Date(startDate);
                dayIndex = 0;
                
                while (currentDate <= endDate) {
                    const dayCell = document.createElement('div');
                    dayCell.className = 'gantt-day-cell';
                    dayCell.dataset.date = formatDate(currentDate);
                    dayCell.dataset.index = dayIndex;
                    
                    if (isWeekend(currentDate)) {
                        dayCell.classList.add('weekend');
                    }
                    if (isHoliday(currentDate)) {
                        dayCell.classList.add('holiday');
                    }
                    if (isVerticalDay(currentDate)) {
                        dayCell.classList.add('vertical-day');
                    }
                    if (isLineNonWorkingDay(currentDate, product.line)) {
                        dayCell.classList.add('vertical-day');
                    }
                    
                    timeline.appendChild(dayCell);
                    
                    currentDate.setDate(currentDate.getDate() + 1);
                    dayIndex++;
                }
                
                row.appendChild(timeline);
                
                // Add position bars
                Object.entries(product.positions).forEach(([posName, posData]) => {
                    const bar = createGanttBar(product, posName, posData);
                    timeline.appendChild(bar);
                });
                
                ganttBody.appendChild(row);
            });
        }

        // Create a Gantt bar for a position
        function createGanttBar(product, positionName, positionData) {
            const bar = document.createElement('div');
            bar.className = `gantt-bar line-${product.line} pos-${positionName}`;
            bar.textContent = `Pos ${positionName}`;
            bar.dataset.productId = product.id;
            bar.dataset.position = positionName;
            bar.dataset.line = product.line;
            bar.dataset.startDate = formatDate(positionData.start);
            bar.dataset.endDate = formatDate(positionData.end);
            
            // Calculate position
            const startDays = Math.floor((positionData.start - startDate) / (1000 * 60 * 60 * 24));
            const duration = Math.floor((positionData.end - positionData.start) / (1000 * 60 * 60 * 24)) + 1;
            
            bar.style.left = `${startDays * 30}px`;
            bar.style.width = `${duration * 30 - 4}px`;
            
            // Make draggable
            bar.draggable = true;
            bar.addEventListener('dragstart', handleDragStart);
            bar.addEventListener('dragend', handleDragEnd);
            
            // Add tooltip events
            bar.addEventListener('mouseenter', handleBarMouseEnter);
            bar.addEventListener('mousemove', handleBarMouseMove);
            bar.addEventListener('mouseleave', handleBarMouseLeave);
            
            return bar;
        }

        let tooltipTimeout = null;
        
        // Tooltip handlers
        function handleBarMouseEnter(e) {
            // Clear any pending hide timeout
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
                tooltipTimeout = null;
            }
            
            const bar = e.target;
            const tooltip = document.getElementById('tooltip');
            
            // Calculate working days
            const product = schedule.find(p => p.id === parseInt(bar.dataset.productId));
            const position = bar.dataset.position;
            const workingDays = product.positions[position].days;
            
            // Format dates nicely
            const startDate = new Date(bar.dataset.startDate);
            const endDate = new Date(bar.dataset.endDate);
            const formatOptions = { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' };
            const startFormatted = startDate.toLocaleDateString('en-US', formatOptions);
            const endFormatted = endDate.toLocaleDateString('en-US', formatOptions);
            
            // Calculate calendar days
            const calendarDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
            
            // Build tooltip content
            const tooltipHTML = `
                <div class="tooltip-row">
                    <span class="tooltip-label">Product:</span>
                    <span class="tooltip-value">${bar.dataset.productId}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Line:</span>
                    <span class="tooltip-value">${bar.dataset.line}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Position:</span>
                    <span class="tooltip-value">${position}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Start:</span>
                    <span class="tooltip-value">${startFormatted}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">End:</span>
                    <span class="tooltip-value">${endFormatted}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Duration:</span>
                    <span class="tooltip-value">${workingDays} working days (${calendarDays} calendar days)</span>
                </div>
            `;
            
            tooltip.innerHTML = tooltipHTML;
            tooltip.classList.add('show');
        }

        function handleBarMouseMove(e) {
            const tooltip = document.getElementById('tooltip');
            
            // Position tooltip near cursor but offset to avoid interference
            let x = e.clientX + 15;
            let y = e.clientY - tooltip.offsetHeight - 10;
            
            // Adjust if tooltip would go off-screen
            if (x + tooltip.offsetWidth > window.innerWidth) {
                x = e.clientX - tooltip.offsetWidth - 15;
            }
            
            if (y < 0) {
                y = e.clientY + 20;
            }
            
            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
        }

        function handleBarMouseLeave(e) {
            const tooltip = document.getElementById('tooltip');
            // Small delay to prevent flickering when moving between bars
            tooltipTimeout = setTimeout(() => {
                tooltip.classList.remove('show');
            }, 100);
        }

        // Drag and drop handlers
        function handleDragStart(e) {
            // Hide tooltip when dragging starts
            const tooltip = document.getElementById('tooltip');
            tooltip.classList.remove('show');
            
            draggedElement = e.target;
            draggedProduct = parseInt(e.target.dataset.productId);
            draggedPosition = e.target.dataset.position;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.innerHTML);
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            
            // Calculate new position based on drop location
            const timeline = e.target.parentElement;
            const rect = timeline.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const dayOffset = Math.round(x / 30);
            
            // Apply horizontal day (delay) to the product
            applyHorizontalDelay(draggedProduct, draggedPosition, dayOffset);
            
            draggedElement = null;
            draggedProduct = null;
            draggedPosition = null;
        }

        // Apply horizontal delay to a product and cascade
        function applyHorizontalDelay(productId, position, dayOffset) {
            const product = schedule.find(p => p.id === productId);
            if (!product) return;
            
            const originalStart = product.positions[position].start;
            const newStart = new Date(startDate);
            newStart.setDate(newStart.getDate() + dayOffset);
            
            const delayDays = Math.floor((newStart - originalStart) / (1000 * 60 * 60 * 24));
            
            if (delayDays <= 0) return; // No delay or moving backward
            
            // Add horizontal days for this product
            if (!horizontalDays[productId]) {
                horizontalDays[productId] = [];
            }
            
            // Add delay days
            let delayDate = new Date(originalStart);
            for (let i = 0; i < delayDays; i++) {
                horizontalDays[productId].push(formatDate(delayDate));
                delayDate.setDate(delayDate.getDate() + 1);
            }
            
            // Recalculate schedule with cascading effect
            cascadeSchedule(product.line, productId);
            
            renderGantt();
            updateStats();
            showToast(`Applied ${delayDays} day delay to Product ${productId}`);
        }

        // Cascade schedule changes for products on the same line
        function cascadeSchedule(line, startingProductId) {
            const lineProducts = schedule.filter(p => p.line === line);
            const startIndex = lineProducts.findIndex(p => p.id === startingProductId);
            
            if (startIndex === -1) return;
            
            // Recalculate affected product and all subsequent products on the same line
            for (let i = startIndex; i < lineProducts.length; i++) {
                const product = lineProducts[i];
                
                // Generate positions dynamically based on what's in the product
                const positions = Object.keys(product.positions).sort((a, b) => {
                    // Sort positions in order: 0, 1, 2, ..., FGI, Delivery
                    if (a === 'Delivery') return 1;
                    if (b === 'Delivery') return -1;
                    if (a === 'FGI') return 1;
                    if (b === 'FGI') return -1;
                    return parseInt(a) - parseInt(b);
                });
                
                if (i === startIndex) {
                    // Recalculate the affected product
                    let positionStart = product.positions['0'].start;
                    
                    positions.forEach((pos, posIndex) => {
                        const daysInPosition = product.positions[pos].days;
                        const positionEnd = addWorkingDays(positionStart, daysInPosition - 1, line, product.id);
                        
                        product.positions[pos].start = new Date(positionStart);
                        product.positions[pos].end = positionEnd;
                        
                        positionStart = addWorkingDays(positionEnd, 1, line, product.id);
                    });
                } else {
                    // Next product starts when previous leaves position 0
                    const prevProduct = lineProducts[i - 1];
                    let positionStart = addWorkingDays(prevProduct.positions['0'].end, 1, line, product.id);
                    
                    positions.forEach((pos, posIndex) => {
                        const daysInPosition = product.positions[pos].days;
                        const positionEnd = addWorkingDays(positionStart, daysInPosition - 1, line, product.id);
                        
                        product.positions[pos].start = new Date(positionStart);
                        product.positions[pos].end = positionEnd;
                        
                        positionStart = addWorkingDays(positionEnd, 1, line, product.id);
                    });
                }
            }
        }

        // Context menu functions
        function showContextMenu(e, date) {
            const menu = document.getElementById('contextMenu');
            menu.style.display = 'block';
            
            // Position the menu at the cursor location
            let x = e.clientX;
            let y = e.clientY;
            
            // Adjust if menu would go off-screen
            const menuRect = menu.getBoundingClientRect();
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            if (x + menu.offsetWidth > windowWidth) {
                x = windowWidth - menu.offsetWidth - 5;
            }
            
            if (y + menu.offsetHeight > windowHeight) {
                y = windowHeight - menu.offsetHeight - 5;
            }
            
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            
            currentContextDate = date;
            
            // Update line-specific menu item
            const lineMenuItem = document.getElementById('lineSpecificMenuItem');
            lineMenuItem.onclick = function() {
                const line = prompt('Enter assembly line (A, B, C, or D):');
                if (line && ['A', 'B', 'C', 'D'].includes(line.toUpperCase())) {
                    addLineNonWorkingDay(line.toUpperCase());
                }
            };
        }

        function closeContextMenu() {
            document.getElementById('contextMenu').style.display = 'none';
        }

        // Add vertical day (all lines)
        function addVerticalDay() {
            if (!verticalDays.includes(currentContextDate)) {
                verticalDays.push(currentContextDate);
                regenerateWithNonWorkingDays();
                showToast(`Added vertical non-working day: ${currentContextDate}`);
            }
            closeContextMenu();
        }

        // Add line-specific non-working day
        function addLineNonWorkingDay(line) {
            if (!lineSpecificNonWorkingDays[line]) {
                lineSpecificNonWorkingDays[line] = [];
            }
            if (!lineSpecificNonWorkingDays[line].includes(currentContextDate)) {
                lineSpecificNonWorkingDays[line].push(currentContextDate);
                regenerateWithNonWorkingDays();
                showToast(`Added non-working day for Line ${line}: ${currentContextDate}`);
            }
            closeContextMenu();
        }

        // Remove non-working day
        function removeNonWorkingDay() {
            let removed = false;
            
            // Remove from vertical days
            const vIndex = verticalDays.indexOf(currentContextDate);
            if (vIndex > -1) {
                verticalDays.splice(vIndex, 1);
                removed = true;
            }
            
            // Remove from line-specific days
            Object.keys(lineSpecificNonWorkingDays).forEach(line => {
                const index = lineSpecificNonWorkingDays[line].indexOf(currentContextDate);
                if (index > -1) {
                    lineSpecificNonWorkingDays[line].splice(index, 1);
                    removed = true;
                }
            });
            
            if (removed) {
                regenerateWithNonWorkingDays();
                showToast(`Removed non-working day: ${currentContextDate}`);
            }
            
            closeContextMenu();
        }

        // Regenerate schedule with non-working days
        function regenerateWithNonWorkingDays() {
            generateSchedule();
        }

        // Update statistics
        function updateStats() {
            document.getElementById('totalProducts').textContent = schedule.length;
            
            if (schedule.length > 0) {
                const lastProduct = schedule[schedule.length - 1];
                const duration = Math.floor((lastProduct.positions['Delivery'].end - startDate) / (1000 * 60 * 60 * 24));
                document.getElementById('scheduleDuration').textContent = `${duration} days`;
            }
            
            const totalNonWorking = verticalDays.length + 
                Object.values(lineSpecificNonWorkingDays).reduce((sum, days) => sum + days.length, 0) +
                Object.values(horizontalDays).reduce((sum, days) => sum + days.length, 0);
            document.getElementById('nonWorkingDays').textContent = totalNonWorking;
        }

        // Save/Load functionality
        function saveSchedule() {
            document.getElementById('saveModal').style.display = 'block';
        }

        function confirmSave() {
            const name = document.getElementById('saveName').value;
            if (!name) {
                alert('Please enter a name for the schedule');
                return;
            }
            
            const data = {
                name: name,
                date: new Date().toISOString(),
                schedule: schedule,
                verticalDays: verticalDays,
                lineSpecificNonWorkingDays: lineSpecificNonWorkingDays,
                horizontalDays: horizontalDays,
                settings: {
                    daysPerPosition: document.getElementById('daysPerPosition').value,
                    daysFGItoDelivery: document.getElementById('daysFGItoDelivery').value,
                    numLines: document.getElementById('numLines').value,
                    numPositions: document.getElementById('numPositions').value,
                    productsPerLine: document.getElementById('productsPerLine').value,
                    startDate: document.getElementById('startDate').value
                }
            };
            
            // Save to localStorage
            let savedSchedules = JSON.parse(localStorage.getItem('manufacturingSchedules') || '{}');
            savedSchedules[name] = data;
            localStorage.setItem('manufacturingSchedules', JSON.stringify(savedSchedules));
            
            closeSaveModal();
            showToast(`Schedule "${name}" saved successfully`);
        }

        function closeSaveModal() {
            document.getElementById('saveModal').style.display = 'none';
            document.getElementById('saveName').value = '';
        }

        function loadSchedule() {
            const savedSchedules = JSON.parse(localStorage.getItem('manufacturingSchedules') || '{}');
            const select = document.getElementById('loadSelect');
            select.innerHTML = '';
            
            Object.keys(savedSchedules).forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = `${name} (${new Date(savedSchedules[name].date).toLocaleDateString()})`;
                select.appendChild(option);
            });
            
            if (select.options.length === 0) {
                alert('No saved schedules found');
                return;
            }
            
            document.getElementById('loadModal').style.display = 'block';
        }

        function confirmLoad() {
            const select = document.getElementById('loadSelect');
            const name = select.value;
            
            const savedSchedules = JSON.parse(localStorage.getItem('manufacturingSchedules') || '{}');
            const data = savedSchedules[name];
            
            if (!data) return;
            
            // Restore schedule data with proper date parsing
            schedule = data.schedule.map(product => ({
                ...product,
                positions: Object.fromEntries(
                    Object.entries(product.positions).map(([pos, data]) => [
                        pos,
                        {
                            ...data,
                            start: new Date(data.start),
                            end: new Date(data.end)
                        }
                    ])
                )
            }));
            
            verticalDays = data.verticalDays || [];
            lineSpecificNonWorkingDays = data.lineSpecificNonWorkingDays || {};
            horizontalDays = data.horizontalDays || {};
            
            // Restore settings
            document.getElementById('daysPerPosition').value = data.settings.daysPerPosition;
            document.getElementById('daysFGItoDelivery').value = data.settings.daysFGItoDelivery;
            document.getElementById('numLines').value = data.settings.numLines;
            document.getElementById('numPositions').value = data.settings.numPositions || 4; // Default to 4 for backwards compatibility
            document.getElementById('productsPerLine').value = data.settings.productsPerLine;
            document.getElementById('startDate').value = data.settings.startDate;
            
            closeLoadModal();
            renderGantt();
            updateStats();
            showToast(`Schedule "${name}" loaded successfully`);
        }

        function closeLoadModal() {
            document.getElementById('loadModal').style.display = 'none';
        }

        // Export to Excel
        function exportToExcel() {
            if (schedule.length === 0) {
                alert('No schedule to export');
                return;
            }
            
            // Create workbook
            const wb = XLSX.utils.book_new();
            
            // Sheet 1: Main Schedule
            const scheduleData = [['Product', 'Assembly Line', 'Position 0 Start', 'Position 0 End', 
                                   'Position 1 Start', 'Position 1 End', 'Position 2 Start', 'Position 2 End',
                                   'Position 3 Start', 'Position 3 End', 'FGI Start', 'FGI End',
                                   'Delivery Start', 'Delivery End']];
            
            schedule.forEach(product => {
                const row = [
                    product.id,
                    product.line,
                    formatDate(product.positions['0'].start),
                    formatDate(product.positions['0'].end),
                    formatDate(product.positions['1'].start),
                    formatDate(product.positions['1'].end),
                    formatDate(product.positions['2'].start),
                    formatDate(product.positions['2'].end),
                    formatDate(product.positions['3'].start),
                    formatDate(product.positions['3'].end),
                    formatDate(product.positions['FGI'].start),
                    formatDate(product.positions['FGI'].end),
                    formatDate(product.positions['Delivery'].start),
                    formatDate(product.positions['Delivery'].end)
                ];
                scheduleData.push(row);
            });
            
            const ws1 = XLSX.utils.aoa_to_sheet(scheduleData);
            XLSX.utils.book_append_sheet(wb, ws1, 'Schedule');
            
            // Sheet 2: Non-Working Days per Product
            const nonWorkingData = [['Product', 'Non-Working Days', 'Count']];
            
            schedule.forEach(product => {
                const productNonWorking = new Set();
                
                // Add vertical days
                verticalDays.forEach(day => productNonWorking.add(day));
                
                // Add line-specific days
                if (lineSpecificNonWorkingDays[product.line]) {
                    lineSpecificNonWorkingDays[product.line].forEach(day => productNonWorking.add(day));
                }
                
                // Add horizontal days
                if (horizontalDays[product.id]) {
                    horizontalDays[product.id].forEach(day => productNonWorking.add(day));
                }
                
                const days = Array.from(productNonWorking).sort().join(', ') || 'None';
                nonWorkingData.push([product.id, days, productNonWorking.size]);
            });
            
            const ws2 = XLSX.utils.aoa_to_sheet(nonWorkingData);
            XLSX.utils.book_append_sheet(wb, ws2, 'Non-Working Days');
            
            // Sheet 3: Working Days per Product
            const workingDaysData = [['Product', 'Position', 'Working Days', 'Calendar Days']];
            
            schedule.forEach(product => {
                Object.entries(product.positions).forEach(([pos, data]) => {
                    const calendarDays = Math.floor((data.end - data.start) / (1000 * 60 * 60 * 24)) + 1;
                    workingDaysData.push([product.id, pos, data.days, calendarDays]);
                });
            });
            
            const ws3 = XLSX.utils.aoa_to_sheet(workingDaysData);
            XLSX.utils.book_append_sheet(wb, ws3, 'Working Days');
            
            // Write file
            XLSX.writeFile(wb, `Manufacturing_Schedule_${formatDate(new Date())}.xlsx`);
            showToast('Schedule exported to Excel successfully');
        }

        // Show toast notification
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Close context menu on click outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.context-menu') && !e.target.closest('.gantt-day-header')) {
                closeContextMenu();
            }
        });
    </script>
</body>
</html>